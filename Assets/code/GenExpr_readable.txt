// VERSION TAG: readable-genexpr-initial (2025-08-30)
// =============================================================================
// JCBReverb GenExpr (readable)
// Uso: pegar en Max/Gen Codebox. Conserva parámetros y funcionalidad.
//
// Guía de lectura rápida:
// 1) Smoothing + I/O: trims (a_INPUT/m_OUTPUT), dry/wet, ruteo `y_IOMODE`.
// 2) PRE (opcional): EQ/COMP antes de la reverb (suavizado `prePostBlend`).
// 3) Pre‑filtros: LPF/HPF (RBJ) a entradas difusores.
// 4) Difusores: Combs (8 por lado) → Allpass (4 por lado), offsets y escalas legibles.
// 5) M/S + width: `msLeft/msRight` via mid/side + `f_ST`/`widthScale`.
// 6) EQ/COMP POST: 3‑band EQ y compresor estéreo, bypass suave según PRE/POST.
// 7) Mezcla Dry/Wet y salida: `out1/out2` (Max requiere estos nombres para outlets).
//
// Bloques:
// - IO: ruteo según `y_IOMODE` (1=mono->mono, 2=mono->stereo, 3=stereo->stereo).
// - Pre/Post: EQ 3 bandas + Comp pueden ir PRE o POST reverb con `x_PREPOST`.
// - Pre-filtros: LPF/HPF RBJ sobre entrada a difusores (parámetros `k_LPF`/`l_HPF`).
// - Difusión: 8 combs por lado (suma normalizada) + 4 allpass por lado.
// - M/S: control de ancho estéreo `f_ST` con `msLeft/msRight` antes de EQ/COMP.
// - Dry/Wet: `b_DRYWET`; trims en dB `a_INPUT` (previo) y `m_OUTPUT` (solo WET).
//
// Parámetros principales:
// - `a_INPUT`/`m_OUTPUT` (dB), `b_DRYWET`, `c_REFLECT`, `d_DAMP`, `e_SIZE`, `f_ST`,
//   `g_FREEZE`, `h_LOWGAIN`, `i_PEAKGAIN`, `j_HIGAIN`, `k_LPF`, `l_HPF`, `n_LOWFREQ`,
//   `o_PEAKFREQ`, `p_HIFREQ`, `q_ONOFFEQ`, `r_ONOFFCOMP`, `s_THD`, `t_RATIO`,
//   `u_ATK`, `v_REL`, `w_MAKEUP`, `x_PREPOST`, `y_IOMODE`.
//
// Seguridad de orden (Gen): mantener lecturas de delay antes de escrituras y
// el orden de histories/feedback. Los cambios de nombres respetan cronología.
// =============================================================================

// =============================================================================
// ÍNDICE DE BLOQUES (flujo y señales)
// =============================================================================
// 1) Smoothing/control mapping
//    - In: Params UI (a_INPUT..y_IOMODE)
//    - Out: prePostBlend, outputTrimLin, compEnableSmoothed, dryWet, eqEnabled,
//           freezeBlend, stereoWidthParam, widthScale, EQ freqs/gains, inputTrimLin
// 2) I/O + Dry path
//    - In: in1/in2
//    - Out: ioL/ioR (wet, con trim y mono route), ioL_raw/ioR_raw (dry), dryL/dryR
// 3) PRE EQ/COMP (opcional)
//    - In: preInputL_sel/preInputR_sel
//    - Out: preL_proc/preR_proc (si prePostBlend activa PRE)
// 4) Pre‑filtros (LPF/HPF)
//    - In: preInputL_sel/preInputR_sel
//    - Out: hpfOutL/hpfOutR (entradas a difusores)
// 5) COMB BANK (L)
//    - In: hpfOutL, reflectCoef, leftCombPass/leak, combDelayL*
//    - Out: earlyLeft
// 6) ALLPASS (L)
//    - In: earlyLeft
//    - Out: msInLeft
// 7) COMB BANK (R)
//    - In: hpfOutR, reflectCoef, rightCombPass/leak, combDelayR*
//    - Out: earlyRight
// 8) ALLPASS (R)
//    - In: earlyRight
//    - Out: msInRight
// 9) M/S + width
//    - In: msInLeft/msInRight, widthScale
//    - Out: msLeft/msRight
// 10) EQ POST (3 bandas)
//    - In: wetPreLeft/wetPreRight
//    - Out: postEqLeft/postEqRight
// 11) COMP POST (estéreo)
//    - In: postEqLeft/postEqRight, comp params
//    - Out: postCOMP_L/postCOMP_R
// 12) Mezcla + salida
//    - In: dryL/dryR, postCOMP_L/R, dryWet, outputTrimLin, isMonoOut
//    - Out: out1/out2

// -----------------------------------------------------------------------------
// SECCION: FUNCIONES (EQ 3 bandas, shelves, peak)
// -----------------------------------------------------------------------------
eq3bandas(sigL, sigR, lf, pf, hf, lg, pg, hg, bw) {
	// Procesa L y R en paralelo manteniendo la salida R encadenada coherente
	// 1) Low-shelf → 2) Peak → 3) High-shelf
	lowL, lowR   = lowshelf(sigL, sigR, lf, lg);
	peakL, peakR = peak(lowL, lowR, pf, pg, bw);
	highL, highR = hishelf(peakL, peakR, hf, hg);
	return highL, highR;
}

lowshelf(sigL, sigR, freq, db) {
    // RBJ-style low-shelf coefficients recalculated on parameter change
    History shelfGain(0);
    History cutoff(0);
    History shelfTerm(0);
    History w(0);
    History a0(0);
    History a1(0);
    if ((change(freq) != 0) || (change(db) != 0)) {
        shelfGain = pow(1.059253692627, db * 0.5);
        cutoff = freq / shelfGain;
        shelfTerm = (shelfGain * shelfGain) - 1;
        w = tan((cutoff * pi) / samplerate);
        a0 = 1 / (w + 1);
        a1 = w - 1;
    }
    leftOut  = lowshelfCore(sigL, a0, a1, shelfTerm, w);
    rightOut = lowshelfCore(sigR, a0, a1, shelfTerm, w);
    return leftOut, rightOut;
}

hishelf(sigL, sigR, freq, db) {
    // RBJ-style high-shelf coefficients recalculated on parameter change
    History shelfGain(0);
    History cutoff(0);
    History shelfTerm(0);
    History w(0);
    History a0(0);
    History a1(0);
    if ((change(freq) != 0) || (change(db) != 0)) {
        shelfGain = pow(1.059253692627, db * 0.25);
        cutoff = min(freq * shelfGain, samplerate);
        shelfTerm = (shelfGain * shelfGain) - 1;
        w = tan((max(cutoff, 0) * pi) / samplerate);
        a0 = 1 / (w + 1);
        a1 = w - 1;
    }
    leftOut  = hishelfCore(sigL, a0, a1, shelfTerm);
    rightOut = hishelfCore(sigR, a0, a1, shelfTerm);
    return leftOut, rightOut;
}

peakCore(input, w, d2, a0, a1, a2) {
    // Two-pole peaking core with simple state update
    History z1(0);
    History z2(0);
    History z3(0);
    History z4(0);
    stage = (input - z2) * w;
    z2 = z1;
    z1 = input;
    biquadOut = a0 * (stage - (a1 * z3) - (a2 * z4));
    z4 = z3;
    z3 = biquadOut;
    out = input + (biquadOut * d2);
    return out;
}

lowshelfCore(input, a0, a1, b1, w) {
    History z1(0);
    x = a0 * (input - (a1 * z1));
    y = w * (x + z1);
    z1 = x;
    return (y * b1) + input;
}

peak(sigL, sigR, freq, db, bw) {
    // RBJ-style peaking EQ core parameters recalculated on change
    History w(0);
    History b0(0);
    History d0(0);
    History d(0);
    History d2(0);
    History wq(0);
    History w2(0);
    History a0(0);
    History a1(0);
    History a2(0);
    if (((change(freq) != 0) || (change(db) != 0)) || (change(bw) != 0)) {
        w = tan((freq * pi) / samplerate);
        b0 = pow(1.059253692627, db * 0.5);
        b = (b0 * b0) - 1;
        d0 = pow(1.4142135381699, bw);
        d = clip(((d0 * d0) - 1) / (d0 * b0), 0.01, 100);
        d2 = d * b;
        wq = d * w;
        w2 = w * w;
        a0 = 1 / ((1 + w2) + wq);
        a1 = (w2 - 1) * 2;
        a2 = (1 + w2) - wq;
    }
    leftOut  = peakCore(sigL, w, d2, a0, a1, a2);
    rightOut = peakCore(sigR, w, d2, a0, a1, a2);
    return leftOut, rightOut;
}

hishelfCore(input, a0, a1, b1) {
    History z1(0);
    x = a0 * (input - (a1 * z1));
    y = x - z1;
    z1 = x;
    out = (y * b1) + input;
    return out;
}

// -----------------------------------------------------------------------------
// PARÁMETROS
// -----------------------------------------------------------------------------
Param a_INPUT(0, min=-12, default=0, max=12); // Input trim in dB (-12..+12, 0dB default)
Param b_DRYWET(0, min=0, default=0.33, max=1.);
Param c_REFLECT(0, min=0.1, default=0.86, max=0.98);
Param d_DAMP(0, min=0, default=0.8, max=0.9); // DAMP: 0 = sin filtro (no damping), 1 = máximo damping
Param e_SIZE(0, min=0.1, default=1, max=4);
Param f_ST(0, min=0, default=0.5, max=0.8);
Param g_FREEZE(0, min=0, default=0, max=1);
Param h_LOWGAIN(0, min=-30, default=0, max=30);
Param i_PEAKGAIN(0, min=-30, default=0, max=30);
Param j_HIGAIN(0, min=-30, default=0, max=30);
Param k_LPF(0, min=100, default=20000, max=20000);
Param l_HPF(0, min=20, default=20, max=5000);
Param m_OUTPUT(0, min=-12, default=0, max=12); // Output trim in dB (-12..+12, 0dB default)
Param n_LOWFREQ(0, min=20, default=500, max=800);
Param o_PEAKFREQ(0, min=100, default=800, max=2500);
Param p_HIFREQ(0, min=800, default=2000, max=15000);
Param q_ONOFFEQ(0, min=0, default=0, max=1);
Param r_ONOFFCOMP(0, min=0, default=0, max=1);
Param s_THD(0, min=-36, default=-12, max=0);
Param t_RATIO(0, min=1, default=2, max=20);
Param u_ATK(0, min=0.1, default=10, max=500);
Param v_REL(0, min=5, default=100, max=1000);
Param w_MAKEUP(0, min=-6, default=0, max=6);
Param x_PREPOST(0, min=0, default=0, max=1); // PRE/POST switch for EQ+COMP relative to reverb (0=post, 1=pre)
Param y_IOMODE(0, min=1, default=3, max=3); // IO layout mode (1=mono->mono, 2=mono->stereo, 3=stereo->stereo)
Param z_BYPASSS(0, min=0, default=0, max=1); // Internal smooth bypass (0=process, 1=bypass to DRY). Host-independent.

//Param z_SOFTCLIP(0, min=0, default=0, max=1); // Softclip enable (0=off, 1=on) — afecta solo a rama WET

Param aa_DUCK_ON(0, min=0, default=0, max=1);         // Duck enable (0=off, 1=on)
Param ab_DUCK_DB(0, min=-60, default=-30, max=0);     // Duck depth in dB (negative values: 0 = no duck, -60 = full reduction)
Param ac_DUCK_ATK(0, min=1, default=10, max=50);      // Duck attack (ms)
Param ad_DUCK_REL(0, min=20, default=200, max=600);   // Duck release (ms)

Param ae_WOBBLE_ON(0, min=0, default=0, max=1);        // Wobble estéreo ON/OFF (solo WET)
Param af_WOBBLE_AMT(0, min=0, default=0.5, max=1);     // Profundidad (0..1 → 0..3 dB)
Param ag_WOBBLE_RATE(0, min=0.1, default=1, max=100); // Velocidad de cambio (Hz)

// -----------------------------------------------------------------------------
// PARÁMETROS INTERNOS (constantes de diseño y escalas)
// -----------------------------------------------------------------------------
// Nota: Las constantes base de COMB/AP se declaran al inicio del procesamiento,
// tras finalizar todos los History/Delay, para respetar el orden de Gen.

// -----------------------------------------------------------------------------
// HISTORIALES Y DELAYS
// -----------------------------------------------------------------------------
History h_outputTrim(0);
History h_prepostGap(0);
History h_softclipEnable(0);
History h_bypass(0);
History h_compEnable(0);
History h_thresholdDb(0);
History h_ratio(0);
History h_attackMs(0);
History h_releaseMs(0);
History h_makeupDb(0);
History h_dryWetStage1(0);
History h_dryWetStage2(0);
History h_eqEnabled(0);
History h_freezeBlend(0);
History h_stereoWidth(0);
History h_lowFreqHz(0);
History h_peakFreqHz(0);
History h_hiFreqHz(0);
History h_lowGainDb(0);
History h_peakGainDb(0);
History h_hiGainDb(0);
History h_inputTrim(0);
History h_sizeScale(0);
History h_lpfHz(0);
History h_hpfHz(0);
History h_reflectCoef(0);
History h_freezeGate(0);
History history_33(0);
History history_34(0);
History history_35(0);
History history_36(0);
History history_37(0);
History history_38(0);
History history_39(0);
History history_40(0);
History history_41(0);
History history_42(0);
History history_43(0);
History history_44(0);
History history_45(0);
History history_46(0);
History history_47(0);
History history_48(0);
History h_combDelayL1(0);
History h_combDelayL2(0);
History h_combDelayL3(0);
History h_combDelayL4(0);
History h_combDelayL5(0);
History h_combDelayL6(0);
History h_combDelayL7(0);
History h_combDelayL8(0);
Delay delay_57(samplerate);
History h_combStateL1(0);
Delay delay_59(samplerate);
History h_combStateL2(0);
Delay delay_61(samplerate);
History h_combStateL3(0);
Delay delay_63(samplerate);
History h_combStateL4(0);
Delay delay_65(samplerate);
History h_combStateL5(0);
Delay delay_67(samplerate);
History h_combStateL6(0);
Delay delay_69(samplerate);
History h_combStateL7(0);
Delay delay_71(samplerate);
History h_combStateL8(0);
Delay delay_73(samplerate);
Delay delay_74(samplerate);
Delay delay_75(samplerate);
Delay delay_76(samplerate);
Delay delay_77(samplerate);
Delay delay_78(samplerate);
Delay delay_79(samplerate);
Delay delay_80(samplerate);
History h_combDelayR1(0);
History h_combDelayR2(0);
History h_combDelayR3(0);
History h_combDelayR4(0);
History h_combDelayR5(0);
History h_combDelayR6(0);
History h_combDelayR7(0);
History h_combDelayR8(0);
Delay delay_89(samplerate);
History h_combStateR1(0);
Delay delay_91(samplerate);
History h_combStateR2(0);
Delay delay_93(samplerate);
History h_combStateR3(0);
Delay delay_95(samplerate);
History h_combStateR4(0);
Delay delay_97(samplerate);
History h_combStateR5(0);
Delay delay_99(samplerate);
History h_combStateR6(0);
Delay delay_101(samplerate);
History h_combStateR7(0);
Delay delay_103(samplerate);
History h_combStateR8(0);
Delay delay_105(samplerate);
Delay delay_106(samplerate);
Delay delay_107(samplerate);
Delay delay_108(samplerate);
Delay delay_109(samplerate);
Delay delay_110(samplerate);
Delay delay_111(samplerate);
Delay delay_112(samplerate);
Delay delay_113(44100);
History h_postRightAccum(0);
History h_postRightOverFlag(0);
Delay delay_116(44100);
History h_postLeftAccum(0);
History h_postLeftOverFlag(0);
// States for optional PRE compressor RMS detectors
Delay delay_preR(44100);
History preR_accum(0);
History preR_flag(0);
Delay delay_preL(44100);
History preL_accum(0);
History preL_flag(0);
// RAW drive RMS windows for pre/post crossfade normalization
// (Eliminados detectores RAW para normalización: enfoque GAP no los usa)
// Smoothed PRE/POST blend state
History prePost_s(0);

History h_wobblePhase(0);
History h_wobbleTarget(0);
History h_wobbleSeed(0.12345);

// -----------------------------------------------------------------------------
// PROCESAMIENTO PRINCIPAL
// -----------------------------------------------------------------------------
// Constantes base (44.1 kHz) de delays de COMB y ALLPASS (visibles arriba)
combBaseL1 = int(1491); combBaseL2 = int(1617); combBaseL3 = int(1188); combBaseL4 = int(1116);
combBaseL5 = int(1557); combBaseL6 = int(1356); combBaseL7 = int(1422); combBaseL8 = int(1277);
combBaseR1 = int(1422); combBaseR2 = int(1491); combBaseR3 = int(1116); combBaseR4 = int(1188);
combBaseR5 = int(1617); combBaseR6 = int(1356); combBaseR7 = int(1277); combBaseR8 = int(1557);
apL1Base = int(255); apL2Base = int(556); apL3Base = int(441); apL4Base = int(341);
apR1Base = int(255); apR2Base = int(556); apR3Base = int(441); apR4Base = int(341);

// Sección: Smoothing de parámetros y mapeos
// (Param aliases retirados: usar Param IDs directamente en el código)
// BLOQUE: Smoothing/control mapping
// - Entradas: parámetros UI en tiempo real (a_INPUT..y_IOMODE)
// - Salidas: versiones suavizadas y escaladas para usar en DSP (p. ej., dryWet, prePostBlend, widthScale, freqs/gains EQ)

// Smoothing de parámetros (factor común)
smoothFactor = 0.999;
oneMinusSmooth = 1 - smoothFactor;

// Mezcla PRE/POST suavizada (para crossfade de ubicación de procesado)
prePostBlend = prePost_s * smoothFactor + x_PREPOST * oneMinusSmooth;

// Trim de salida (dB → lineal) suavizado
outputTrimLin = h_outputTrim * smoothFactor + dbtoa(m_OUTPUT) * oneMinusSmooth;
next_outputTrim = fixdenorm(outputTrimLin);

// Compresor: on/off suavizado
compEnableSmoothed = h_compEnable * smoothFactor + r_ONOFFCOMP * oneMinusSmooth;
next_compEnable = fixdenorm(compEnableSmoothed);

// Softclip on/off suavizado
//softclipEnabled = h_softclipEnable * smoothFactor + z_SOFTCLIP * oneMinusSmooth;
//next_softclipEnable = fixdenorm(softclipEnabled);

// Bypass interno inmediato (0=process, 1=bypass a DRY)
// Rationale: smoothing aquí puede dejar la salida en estados intermedios tras reanudar
// causando mutes transitorios si WET≈0. Hacemos la conmutación instantánea y el host
// gestiona cualquier transición visual.
bypassSmoothed = z_BYPASSS;
next_bypass = bypassSmoothed;

// Threshold/ratio y tiempos del compresor (suavizados)
thresholdDb = h_thresholdDb * smoothFactor + s_THD * oneMinusSmooth;
next_thresholdDb = fixdenorm(thresholdDb);
ratio = h_ratio * smoothFactor + t_RATIO * oneMinusSmooth;
next_ratio = fixdenorm(ratio);
attackMs = h_attackMs * smoothFactor + u_ATK * oneMinusSmooth;
next_attackMs = fixdenorm(attackMs);
releaseMs = h_releaseMs * smoothFactor + v_REL * oneMinusSmooth;
next_releaseMs = fixdenorm(releaseMs);
makeupDb = h_makeupDb * smoothFactor + w_MAKEUP * oneMinusSmooth;
next_makeupDb = fixdenorm(makeupDb);

// Dry/Wet suavizado (doble etapa)
dryWet = h_dryWetStage1 * smoothFactor + b_DRYWET * oneMinusSmooth;
next_dryWetStage1 = fixdenorm(dryWet);
dryWet = h_dryWetStage2 * smoothFactor + dryWet * oneMinusSmooth;
next_dryWetStage2 = fixdenorm(dryWet);

// Constantes útiles
zero = float(0.);

// EQ on/off suavizado
eqEnabled = h_eqEnabled * smoothFactor + q_ONOFFEQ * oneMinusSmooth;
next_eqEnabled = fixdenorm(eqEnabled);

// Freeze suavizado
freezeOn = g_FREEZE == 1;
freezeBlend = h_freezeBlend * smoothFactor + freezeOn * oneMinusSmooth;
next_freezeBlend = fixdenorm(freezeBlend);

// Control de ancho estéreo y escala de width
stereoWidthParam = h_stereoWidth * smoothFactor + f_ST * oneMinusSmooth;
next_stereoWidth = fixdenorm(stereoWidthParam);
widthScale = scale(stereoWidthParam, 0, 0.8, 0.707, 1., 1);

// PRE/POST energy latch: only allow PRE/POST blend to move when drive RMS is low

// EQ 3 bandas: freqs y gains suavizados
lowFreqHz = h_lowFreqHz * smoothFactor + n_LOWFREQ * oneMinusSmooth;
next_lowFreqHz = fixdenorm(lowFreqHz);
peakFreqHz = h_peakFreqHz * smoothFactor + o_PEAKFREQ * oneMinusSmooth;
next_peakFreqHz = fixdenorm(peakFreqHz);
hiFreqHz = h_hiFreqHz * smoothFactor + p_HIFREQ * oneMinusSmooth;
next_hiFreqHz = fixdenorm(hiFreqHz);
lowGainDb = h_lowGainDb * smoothFactor + h_LOWGAIN * oneMinusSmooth;
next_lowGainDb = fixdenorm(lowGainDb);
peakGainDb = h_peakGainDb * smoothFactor + i_PEAKGAIN * oneMinusSmooth;
next_peakGainDb = fixdenorm(peakGainDb);
hiGainDb = h_hiGainDb * smoothFactor + j_HIGAIN * oneMinusSmooth;
next_hiGainDb = fixdenorm(hiGainDb);

// Input trim (dB → lineal) suavizado
inputTrimLin = h_inputTrim * smoothFactor + dbtoa(a_INPUT) * oneMinusSmooth;
next_inputTrim = fixdenorm(inputTrimLin);

// -----------------------------------------------------------------------------
// Sección: I/O y trayecto seco (dry)
// BLOQUE: Entradas y ruteo
// - Entradas: in1/in2 del patcher
// - Salidas: ioL/ioR (ruta WET con trim/mono route), ioL_raw/ioR_raw (ruta DRY sin trim), dryL/dryR (para mezcla final)
// Entradas crudas y versiones con trim
// DRY debe usar la señal de entrada sin trim; WET usa trimmed
leftRaw = in1; rightRaw = in2;
leftTrimmed = in1 * inputTrimLin;
rightTrimmed = in2 * inputTrimLin;

// Flags de I/O
ioMode = y_IOMODE;
isMonoIn = ((ioMode == 1) || (ioMode == 2));
isMonoOut = (ioMode == 1);

// Ruteo mono para WET (trimmed)
inMonoRoute = (leftTrimmed + rightTrimmed) * 0.5;
ioL = mix(leftTrimmed, inMonoRoute, isMonoIn);
ioR = mix(rightTrimmed, inMonoRoute, isMonoIn);

// Ruteo mono para DRY (raw, sin trim)
inMonoRouteRaw = (leftRaw + rightRaw) * 0.5;
ioL_raw = mix(leftRaw, inMonoRouteRaw, isMonoIn);
ioR_raw = mix(rightRaw, inMonoRouteRaw, isMonoIn);

// Trayecto seco (usar raw, sin auto-detección): Left primero, luego Right
dryLMix = mix(ioL_raw, zero, freezeBlend);
dryRMix = mix(ioR_raw, zero, freezeBlend);

// Aliases de salida Dry
dryL = dryLMix;
dryR = dryRMix;
widthComplement = 1 - stereoWidthParam;

// Ganancias de spread estéreo (pre-M/S)
stereoSpreadMid = sqrt(widthComplement);
stereoSpreadSide = sqrt(stereoWidthParam);
apBaseL = int(0);
apGainL = float(0.5);
apBaseR = int(0);
apGainR = float(0.5);
// Invertido: 0 = sin damping (pass=0, leak=1), 1 = máximo damping (pass=0.9, leak=0)
clampedDamp = min(d_DAMP, 0.9);
dampPass = clampedDamp;
dampLeak = 1 - clampedDamp;

lpfPrev = h_lpfHz * 0.999;
lpfInputScaled = k_LPF * 0.001;
lpfHzSmoothed = lpfInputScaled + lpfPrev;
lpfHz = lpfHzSmoothed;
nextLpfHz = fixdenorm(lpfHzSmoothed);
hpfPrev = h_hpfHz * 0.999;
hpfInputScaled = l_HPF * 0.001;
hpfHzSmoothed = hpfInputScaled + hpfPrev;
hpfHz = hpfHzSmoothed;
nextHpfHz = fixdenorm(hpfHzSmoothed);
unity = float(1.);

// (aliases redundantes de amortiguación eliminados)
sizeScalePrev = h_sizeScale * 0.999;
sizeInputScaled = e_SIZE * 0.001;
sizeScaleSmoothed = sizeInputScaled + sizeScalePrev;
nextSizeScale = fixdenorm(sizeScaleSmoothed);

// Tamaño efectivo: no tocar con FREEZE y sin clamp por debajo de 1
// (mantenemos un techo de seguridad en 4.0 para evitar overflows)
sizeScaleEff = min(sizeScaleSmoothed, 4.0);
sizeScaleL = sizeScaleEff;
sizeScaleR = sizeScaleEff;
// Baselines
leftBaselineSamples = int(0); // baseline samples for left
// En FREEZE forzamos reflect a 1.0 de forma explícita y portable
reflectBase = mix(c_REFLECT, 1, freezeOn);
reflectPrev = h_reflectCoef * 0.999;
reflectInputScaled = reflectBase * 0.001;
reflectCoefSmoothed = reflectInputScaled + reflectPrev;
nextReflectCoef = fixdenorm(reflectCoefSmoothed);

// Alias de coeficiente de reflexión
reflectCoef = reflectCoefSmoothed;
baseOffsetUnits = int(23);

// (re-asignación redundante eliminada) sizeScaleR ya proviene de sizeScaleSmoothed
offsetSamplesR = baseOffsetUnits * sizeScaleR;

// Control de ancho según modo explícito (sin auto-detección)
// - MONO OUT: ancho = 0; MONO->ST y ST-ST: ancho = stereoWidthParam
widthControl = mix(stereoWidthParam, zero, isMonoOut);

// Symmetric base-offsets for diffuser chains
offsetSamplesL = leftBaselineSamples;     // 0 samples (left baseline)
baseZeroL = zero;             // 0
baseZeroR = zero;             // 0
baseOffsetL = mix(baseZeroL, offsetSamplesL, widthControl);
baseOffsetR = mix(baseZeroR, offsetSamplesR, widthControl);
freezeComplement = 1 - (g_FREEZE == 1);
freezePrev = h_freezeGate * 0.999;
freezeInputScaled = freezeComplement * 0.001;
freezeGateSmoothed = freezeInputScaled + freezePrev;
nextFreezeGate = fixdenorm(freezeGateSmoothed);
// FREEZE: cortar entrada inmediatamente cuando está activo (sin smoothing)
preInputR = ioR * (1 - freezeOn);
preInputL = ioL * (1 - freezeOn);

// -----------------------------------------------------------------------------
// Sección: PRE (opcional) EQ + COMP antes de reverb
// BLOQUE: Preprocesado
// - Entradas: preInputL_sel/preInputR_sel (tras freeze/mono routing)
// - Salidas: preL_proc/preR_proc (si prePostBlend activa PRE), o bypass a preInput*
// - Nota: reutiliza los mismos controles que el POST (EQ/COMP), con crossfade por prePostBlend
preEQ_L_raw, preEQ_R_raw = eq3bandas(preInputL, preInputR,
    lowFreqHz, peakFreqHz, hiFreqHz, lowGainDb, peakGainDb, hiGainDb, 1);
preEQ_L = mix(preInputL, preEQ_L_raw, eqEnabled);
preEQ_R = mix(preInputR, preEQ_R_raw, eqEnabled);

// Pre COMP (RMS window ~300 samples) con A/R, ratio y makeup
pre_relSamps = mstosamps(releaseMs);
pre_atkSamps = mstosamps(attackMs);
pre_win = int(300);

// -----------------------------------------------------------------------------
// (Eliminado bloque de normalización por RMS del drive RAW: no se usa en enfoque gap)

// Detector RMS Left (PRE)
preLeftTap = delay_preL.read(pre_win);
preLeftEnergy = preEQ_L * preEQ_L;
preLeftAccum = preL_accum + preLeftEnergy;
preLeftDiff = preLeftAccum - preLeftTap;
preLeftAvg = preLeftDiff / pre_win;
preLeftRms = sqrt(preLeftAvg);
preL_accum_next = fixdenorm(preLeftDiff);
preLeftDb = atodb(preLeftRms);
preLeftLvlDb = max(preLeftDb, -96);
preLeftOver = preLeftLvlDb > thresholdDb;
preLeftFlagSmoothed = (preL_flag * 0.999) + (preLeftOver * 0.001);
preL_flag_s = preLeftFlagSmoothed;
preLeftGainDb = (thresholdDb - preLeftLvlDb) * (1 - (1 / ratio));
preLeftGainLin = dbtoa(preLeftGainDb);
preLeftEnvTarget = mix(1, preLeftGainLin, preLeftOver);
preLeftEnv = slide(preLeftEnvTarget, pre_relSamps, pre_atkSamps);
preL_out = (preEQ_L * preLeftEnv) * dbtoa(makeupDb);

// Detector RMS Right (PRE)
preRightTap = delay_preR.read(pre_win);
preRightEnergy = preEQ_R * preEQ_R;
preRightAccum = preR_accum + preRightEnergy;
preRightDiff = preRightAccum - preRightTap;
preRightAvg = preRightDiff / pre_win;
preRightRms = sqrt(preRightAvg);
preR_accum_next = fixdenorm(preRightDiff);
preRightDb = atodb(preRightRms);
preRightLvlDb = max(preRightDb, -96);
preRightOver = preRightLvlDb > thresholdDb;
preRightFlagSmoothed = (preR_flag * 0.999) + (preRightOver * 0.001);
preR_flag_s = preRightFlagSmoothed;
preRightGainDb = (thresholdDb - preRightLvlDb) * (1 - (1 / ratio));
preRightGainLin = dbtoa(preRightGainDb);
preRightEnvTarget = mix(1, preRightGainLin, preRightOver);
preRightEnv = slide(preRightEnvTarget, pre_relSamps, pre_atkSamps);
preR_out = (preEQ_R * preRightEnv) * dbtoa(makeupDb);

// Aplicar bypass de COMP (usa compEnableSmoothed) sobre el camino PRE
preR_proc = mix(preEQ_R, preR_out, compEnableSmoothed);
preL_proc = mix(preEQ_L, preL_out, compEnableSmoothed);

// Selección de entrada a filtros de reverb (0=original, 1=pre-procesada)
// Equal-power crossfade para entrada a reverb (reduce saltos de energía)
// Enfoque GAP: procesadores siempre corren; conmutador binario + microgap de ~10ms (decay 0.98)
prePostBinary = x_PREPOST > 0.5;
prePostSwitch = change(x_PREPOST) != 0;
gapEnv = max(h_prepostGap * 0.98, prePostSwitch);
next_prepostGap = fixdenorm(gapEnv);
feedGate = 1 - gapEnv;
preInputR_sel = mix(preInputR, preR_proc, prePostBinary) * feedGate;
preInputL_sel = mix(preInputL, preL_proc, prePostBinary) * feedGate;

// -----------------------------------------------------------------------------
// Sección: Pre‑filtros (LPF/HPF) a entradas de reverb
// BLOQUE: Filtrado de entrada a difusores
// - Entradas: preInputL_sel / preInputR_sel
// - Procesado: LPF/HPF RBJ biquad por canal
// - Salidas: hpfOutL / hpfOutR (alimentan bancos de combs L/R)
// - Entradas legibles a pre‑filtros
preFilterInR = preInputR_sel * freezeGateSmoothed;
preFilterInL = preInputL_sel * freezeGateSmoothed;

// Coeficientes LPF (biquad RBJ)
omega = ((lpfHz * twopi)) / samplerate;
sn = sin(omega);
cs = cos(omega);
one_over_Q = 1 / unity;
alpha = ((sn * 0.5)) * one_over_Q;
b0 = 1 / ((1 + alpha));
a2 = ((((1 - cs)) * 0.5)) * b0;
a1 = ((1 - cs)) * b0;
b1 = ((-2 * cs)) * b0;
b2 = ((1 - alpha)) * b0;

// Coeficientes LPF biquad (nombrados)
lpfA2   = a2;  // feedforward a2
lpfA1   = a1;  // feedforward a1
lpfA2_b = a2;  // feedforward a2 (segundo término)
lpfB1   = b1;  // feedback b1
lpfB2   = b2;  // feedback b2
omega_324 = ((hpfHz * twopi)) / samplerate;
sn_325 = sin(omega_324);
cs_326 = cos(omega_324);
alpha_327 = ((sn_325 * 0.5)) / unity;
b_328 = 1 / ((1 + alpha_327));
a_329 = ((((1 + cs_326)) * 0.5)) * b_328;
a_330 = (-(1 + cs_326)) * b_328;
b_331 = ((-2 * cs_326)) * b_328;
b_332 = ((1 - alpha_327)) * b_328;

// Coeficientes HPF biquad (nombrados)
hpfA2   = a_329; // feedforward a2
hpfA1   = a_330; // feedforward a1
hpfA2_b = a_329; // feedforward a2 (segundo término)
hpfB1   = b_331; // feedback b1
hpfB2   = b_332; // feedback b2

// LPF biquad (L/R) — forma directa (coeficientes nombrados)
lpfOutL = (preFilterInL * lpfA2) + (history_37 * lpfA1) + (history_34 * lpfA2_b)
          - ((history_40 * lpfB1) + (history_36 * lpfB2));
lpfOutR = (preFilterInR * lpfA2) + (history_38 * lpfA1) + (history_33 * lpfA2_b)
          - ((history_39 * lpfB1) + (history_35 * lpfB2));
          
history_33_next_352 = fixdenorm(history_38);
history_34_next_353 = fixdenorm(history_37);
history_35_next_354 = fixdenorm(history_39);
history_36_next_355 = fixdenorm(history_40);
nextPreInputL = fixdenorm(preInputL_sel);
nextPreInputR = fixdenorm(preInputR_sel);
nextLpfOutR = fixdenorm(lpfOutR);
nextLpfOutL = fixdenorm(lpfOutL);

// -----------------------------------------------------------------------------
// Sección: HPF biquad (L/R)
// BLOQUE: Salida de pre‑filtros hacia COMB
// - Entradas: lpfOutL/lpfOutR + coeficientes hpfA*/hpfB*
// - Salidas: hpfOutL/hpfOutR (alimentan COMB L/R)

// HPF Right
hpfOutR = (lpfOutR * hpfA2) + (history_45 * hpfA1) + (history_44 * hpfA2_b)
          - ((history_47 * hpfB1) + (history_41 * hpfB2));

// HPF Left
hpfOutL = (lpfOutL * hpfA2) + (history_46 * hpfA1) + (history_42 * hpfA2_b)
          - ((history_48 * hpfB1) + (history_43 * hpfB2));

// HPF state updates
history_41_next_374 = fixdenorm(history_47);
history_42_next_375 = fixdenorm(history_46);
history_43_next_376 = fixdenorm(history_48);
history_44_next_377 = fixdenorm(history_45);
history_45_next_378 = fixdenorm(lpfOutR);
history_46_next_379 = fixdenorm(lpfOutL);
history_47_next_380 = fixdenorm(hpfOutR);
history_48_next_381 = fixdenorm(hpfOutL);

// -----------------------------------------------------------------------------
// Entrada a COMB (L): usar hpfOutL directamente

// Coeficientes comunes comb (Left)
// BLOQUE: COMB BANK (LEFT)
// - Entradas: hpfOutL, reflectCoef, leftCombPass/leak, delays combDelayL*Smoothed
// - Salidas: combL1Out..combL8Out → combMixLeft → earlyLeft

leftCombLeak = dampLeak;   // leak = d_DAMP
leftCombPass = dampPass;   // pass = 1 - d_DAMP

// Comb bank (Left) - 8 líneas
// Comb base delays at 44.1kHz (Left)
combBaseL1 = int(1491);
combBaseL2 = int(1617);

// combBaseL* definidos arriba (Constantes de diseño)
sampleRateScaleL = samplerate / 44100;
combScaleL = sampleRateScaleL * sizeScaleL;
combDelayL1Scaled = combBaseL1 * combScaleL;
combDelayL1Smoothed = (h_combDelayL1 * 0.999) + (combDelayL1Scaled * 0.001);
next_combDelayL1 = fixdenorm(combDelayL1Smoothed);
combDelayL2Scaled = combBaseL2 * combScaleL;
combDelayL2Smoothed = (h_combDelayL2 * 0.999) + (combDelayL2Scaled * 0.001);
next_combDelayL2 = fixdenorm(combDelayL2Smoothed);
combDelayL3Scaled = combBaseL3 * combScaleL;
combDelayL3Smoothed = (h_combDelayL3 * 0.999) + (combDelayL3Scaled * 0.001);
next_combDelayL3 = fixdenorm(combDelayL3Smoothed);
combDelayL4Scaled = combBaseL4 * combScaleL;
combDelayL4Smoothed = (h_combDelayL4 * 0.999) + (combDelayL4Scaled * 0.001);
next_combDelayL4 = fixdenorm(combDelayL4Smoothed);
combDelayL5Scaled = combBaseL5 * combScaleL;
combDelayL5Smoothed = (h_combDelayL5 * 0.999) + (combDelayL5Scaled * 0.001);
next_combDelayL5 = fixdenorm(combDelayL5Smoothed);
combDelayL6Scaled = combBaseL6 * combScaleL;
combDelayL6Smoothed = (h_combDelayL6 * 0.999) + (combDelayL6Scaled * 0.001);
next_combDelayL6 = fixdenorm(combDelayL6Smoothed);
combDelayL7Scaled = combBaseL7 * combScaleL;
combDelayL7Smoothed = (h_combDelayL7 * 0.999) + (combDelayL7Scaled * 0.001);
next_combDelayL7 = fixdenorm(combDelayL7Smoothed);
combDelayL8Scaled = combBaseL8 * combScaleL;
combDelayL8Smoothed = (h_combDelayL8 * 0.999) + (combDelayL8Scaled * 0.001);
next_combDelayL8 = fixdenorm(combDelayL8Smoothed);

// 1 - leak (porción pasada) ya definido como leftCombPass
// --- Comb L1 (Left) ---
// Inputs: combL1DelayOffset, leftCombLeak/leftCombPass, reflectCoef, hpfOutL
// Output: combL1Out (feeds combMixLeft)
combL1FeedbackScaled = h_combStateL1 * leftCombPass;

delayOffsetL1Samples = combDelayL4Smoothed;
combL1DelayOffset = clip(baseOffsetL + delayOffsetL1Samples, 0, samplerate - 1);

combL1Tap = delay_57.read(combL1DelayOffset, interp="linear");

combL1TapScaled = combL1Tap * leftCombLeak;
combL1Mix = combL1TapScaled + combL1FeedbackScaled;

combL1Feedforward = combL1Mix * reflectCoef;
combL1Sum = hpfOutL + combL1Feedforward;
combL1Out = combL1Sum;

next_combStateL1 = fixdenorm(combL1Mix);
// --- Comb L2 (Left) ---
// Inputs: combL2DelayOffset, leftCombLeak/leftCombPass, reflectCoef, hpfOutL
// Output: combL2Out
// --- Comb L2 (Left) ---
combL2FeedbackScaled = h_combStateL2 * leftCombPass;

delayOffsetL2Samples = combDelayL3Smoothed;
combL2DelayOffset = clip(baseOffsetL + delayOffsetL2Samples, 0, samplerate - 1);

combL2Tap = delay_59.read(combL2DelayOffset, interp="linear");

combL2TapScaled = combL2Tap * leftCombLeak;
combL2Mix = combL2TapScaled + combL2FeedbackScaled;

combL2Feedforward = combL2Mix * reflectCoef;
combL2Sum = hpfOutL + combL2Feedforward;
combL2Out = combL2Sum;

next_combStateL2 = fixdenorm(combL2Mix);
// --- Comb L3 (Left) ---
// Inputs: combL3DelayOffset, leftCombLeak/leftCombPass, reflectCoef, hpfOutL
// Output: combL3Out
// --- Comb L3 (Left) ---
combL3FeedbackScaled = h_combStateL3 * leftCombPass;

delayOffsetL3Samples = combDelayL6Smoothed;
combL3DelayOffset = clip(baseOffsetL + delayOffsetL3Samples, 0, samplerate - 1);

combL3Tap = delay_61.read(combL3DelayOffset, interp="linear");

combL3TapScaled = combL3Tap * leftCombLeak;
combL3Mix = combL3TapScaled + combL3FeedbackScaled;

combL3Feedforward = combL3Mix * reflectCoef;
combL3Sum = hpfOutL + combL3Feedforward;
combL3Out = combL3Sum;

next_combStateL3 = fixdenorm(combL3Mix);
// --- Comb L4 (Left) ---
// Inputs: combL4DelayOffset, leftCombLeak/leftCombPass, reflectCoef, hpfOutL
// Output: combL4Out
// --- Comb L4 (Left) ---
combL4FeedbackScaled = h_combStateL4 * leftCombPass;

delayOffsetL4Samples = combDelayL8Smoothed;
combL4DelayOffset = clip(baseOffsetL + delayOffsetL4Samples, 0, samplerate - 1);

combL4Tap = delay_63.read(combL4DelayOffset, interp="linear");

combL4TapScaled = combL4Tap * leftCombLeak;
combL4Mix = combL4TapScaled + combL4FeedbackScaled;

combL4Feedforward = combL4Mix * reflectCoef;
combL4Sum = hpfOutL + combL4Feedforward;
combL4Out = combL4Sum;

next_combStateL4 = fixdenorm(combL4Mix);
// --- Comb L5 (Left) ---
// Inputs: combL5DelayOffset, leftCombLeak/leftCombPass, reflectCoef, hpfOutL
// Output: combL5Out
// --- Comb L5 (Left) ---
combL5FeedbackScaled = h_combStateL5 * leftCombPass;

delayOffsetL5Samples = combDelayL7Smoothed;
combL5DelayOffset = clip(baseOffsetL + delayOffsetL5Samples, 0, samplerate - 1);

combL5Tap = delay_65.read(combL5DelayOffset, interp="linear");

combL5TapScaled = combL5Tap * leftCombLeak;
combL5Mix = combL5TapScaled + combL5FeedbackScaled;

combL5Feedforward = combL5Mix * reflectCoef;
combL5Sum = hpfOutL + combL5Feedforward;
combL5Out = combL5Sum;

next_combStateL5 = fixdenorm(combL5Mix);
// --- Comb L6 (Left) ---
// Inputs: combL6DelayOffset, leftCombLeak/leftCombPass, reflectCoef, hpfOutL
// Output: combL6Out
// --- Comb L6 (Left) ---
combL6FeedbackScaled = h_combStateL6 * leftCombPass;

delayOffsetL6Samples = combDelayL1Smoothed;
combL6DelayOffset = clip(baseOffsetL + delayOffsetL6Samples, 0, samplerate - 1);

combL6Tap = delay_67.read(combL6DelayOffset, interp="linear");

combL6TapScaled = combL6Tap * leftCombLeak;
combL6Mix = combL6TapScaled + combL6FeedbackScaled;

combL6Feedforward = combL6Mix * reflectCoef;
combL6Sum = hpfOutL + combL6Feedforward;
combL6Out = combL6Sum;

next_combStateL6 = fixdenorm(combL6Mix);
// --- Comb L7 (Left) ---
// Inputs: combL7DelayOffset, leftCombLeak/leftCombPass, reflectCoef, hpfOutL
// Output: combL7Out
// --- Comb L7 (Left) ---
combL7FeedbackScaled = h_combStateL7 * leftCombPass;

delayOffsetL7Samples = combDelayL2Smoothed;
combL7DelayOffset = clip(baseOffsetL + delayOffsetL7Samples, 0, samplerate - 1);

combL7Tap = delay_69.read(combL7DelayOffset, interp="linear");

combL7TapScaled = combL7Tap * leftCombLeak;
combL7Mix = combL7TapScaled + combL7FeedbackScaled;

combL7Feedforward = combL7Mix * reflectCoef;
combL7Sum = hpfOutL + combL7Feedforward;
combL7Out = combL7Sum;

next_combStateL7 = fixdenorm(combL7Mix);
// --- Comb L8 (Left) ---
// Inputs: combL8DelayOffset, leftCombLeak/leftCombPass, reflectCoef, hpfOutL
// Output: combL8Out
// --- Comb L8 (Left) ---
combL8FeedbackScaled = h_combStateL8 * leftCombPass;

delayOffsetL8Samples = combDelayL5Smoothed;
combL8DelayOffset = clip(baseOffsetL + delayOffsetL8Samples, 0, samplerate - 1);

combL8Tap = delay_71.read(combL8DelayOffset, interp="linear");

combL8TapScaled = combL8Tap * leftCombLeak;
combL8Mix = combL8TapScaled + combL8FeedbackScaled;

combL8Feedforward = combL8Mix * reflectCoef;
combL8Sum = hpfOutL + combL8Feedforward;
combL8Out = combL8Sum;

next_combStateL8 = fixdenorm(combL8Mix);
// Suma normalizada del banco de combs (Left) → early reflections
combMixLeft = ((((((((((((((combL8Out + combL7Out)) + combL6Out)) + combL5Out)) + combL4Out)) + combL3Out)) + combL2Out)) + combL1Out)) * 0.125;
earlyLeft = combMixLeft;

// -----------------------------------------------------------------------------
// ALLPASS DIFFUSER CHAIN (LEFT) — 4 STAGES
// BLOQUE: Difusores allpass L
// - Entradas: earlyLeft
// - Salida: msInLeft (entrada a matriz M/S)

// apL*Base definidos arriba (Constantes de diseño)
sampleRateScaleAP_L = samplerate / 44100;
apScaleL = sampleRateScaleAP_L * sizeScaleEff;
apL1DelaySamples = apL1Base * apScaleL;
apL1DelayOffset = clip(apBaseL + apL1DelaySamples, 0, samplerate - 1);
apL1TapA = delay_73.read(apL1DelayOffset, interp="linear");
apL1TapB = delay_74.read(apL1DelayOffset, interp="linear");
// apL1: usar alias de taps para claridad
apL1Sum = (earlyLeft * (apGainL * -1)) + (apL1TapA + apL1TapB * apGainL);
// Allpass etapas (Left)
apL1 = apL1Sum;
// sampleRateScaleAP_L y apScaleL reutilizados
apL2DelaySamples = apL2Base * apScaleL;
apL2DelayOffset = clip(apBaseL + apL2DelaySamples, 0, samplerate - 1);
apL2TapA = delay_75.read(apL2DelayOffset, interp="linear");
apL2TapB = delay_76.read(apL2DelayOffset, interp="linear");
apL2Sum = apL1 * (apGainL * -1) + (apL2TapA + apL2TapB * apGainL);
apL2 = apL2Sum;
// sampleRateScaleAP_L y apScaleL reutilizados
apL3DelaySamples = apL3Base * apScaleL;
apL3DelayOffset = clip(apBaseL + apL3DelaySamples, 0, samplerate - 1);
apL3TapA = delay_77.read(apL3DelayOffset, interp="linear");
apL3TapB = delay_78.read(apL3DelayOffset, interp="linear");
apL3Sum = apL2 * (apGainL * -1) + (apL3TapA + apL3TapB * apGainL);
apL3 = apL3Sum;
// sampleRateScaleAP_L y apScaleL reutilizados
apL4DelaySamples = apL4Base * apScaleL;
apL4DelayOffset = clip(apBaseL + apL4DelaySamples, 0, samplerate - 1);
apL4TapA = delay_79.read(apL4DelayOffset, interp="linear");
apL4TapB = delay_80.read(apL4DelayOffset, interp="linear");
apL4Sum = apL3 * (apGainL * -1) + (apL4TapA + apL4TapB * apGainL);
apL4 = apL4Sum;

// Entrada a matriz M/S (L) desde el último allpass
msInLeft = apL4;

// -----------------------------------------------------------------------------
// M/S MATRIX + WIDTH (PRE EQ/COMP)
// BLOQUE: Matriz Mid/Side y control de ancho
// - Entradas: msInLeft/msInRight (desde allpass L/R), stereoSpreadMid/Side, widthScale
// - Salidas: msLeft/msRight (húmedo antes de EQ/COMP POST)
// Salida pre-filtros (R)
// Coeficientes comunes comb (Right)
// BLOQUE: COMB BANK (RIGHT)
// - Entradas: hpfOutR, reflectCoef, rightCombPass/leak, delays combDelayR*Smoothed
// - Salidas: combR1Out..combR8Out → combMixRight → earlyRight
rightCombLeak = dampLeak;
rightCombPass = dampPass;

// Comb base delays at 44.1kHz (Right)
// combBaseR* definidos arriba (Constantes de diseño)
sampleRateScaleR = samplerate / 44100;
combScaleR = sampleRateScaleR * sizeScaleR;
combDelayR1Scaled = combBaseR1 * combScaleR;
combDelayR1Smoothed = (h_combDelayR1 * 0.999) + (combDelayR1Scaled * 0.001);
next_combDelayR1 = fixdenorm(combDelayR1Smoothed);
combDelayR2Scaled = combBaseR2 * combScaleR;
combDelayR2Smoothed = (h_combDelayR2 * 0.999) + (combDelayR2Scaled * 0.001);
next_combDelayR2 = fixdenorm(combDelayR2Smoothed);
combDelayR3Scaled = combBaseR3 * combScaleR;
combDelayR3Smoothed = (h_combDelayR3 * 0.999) + (combDelayR3Scaled * 0.001);
next_combDelayR3 = fixdenorm(combDelayR3Smoothed);
combDelayR4Scaled = combBaseR4 * combScaleR;
combDelayR4Smoothed = (h_combDelayR4 * 0.999) + (combDelayR4Scaled * 0.001);
next_combDelayR4 = fixdenorm(combDelayR4Smoothed);
combDelayR5Scaled = combBaseR5 * combScaleR;
combDelayR5Smoothed = (h_combDelayR5 * 0.999) + (combDelayR5Scaled * 0.001);
next_combDelayR5 = fixdenorm(combDelayR5Smoothed);
combDelayR6Scaled = combBaseR6 * combScaleR;
combDelayR6Smoothed = (h_combDelayR6 * 0.999) + (combDelayR6Scaled * 0.001);
next_combDelayR6 = fixdenorm(combDelayR6Smoothed);
combDelayR7Scaled = combBaseR7 * combScaleR;
combDelayR7Smoothed = (h_combDelayR7 * 0.999) + (combDelayR7Scaled * 0.001);
next_combDelayR7 = fixdenorm(combDelayR7Smoothed);
combDelayR8Scaled = combBaseR8 * combScaleR;
combDelayR8Smoothed = (h_combDelayR8 * 0.999) + (combDelayR8Scaled * 0.001);
next_combDelayR8 = fixdenorm(combDelayR8Smoothed);

// -----------------------------------------------------------------------------
// COMB BANK (RIGHT) — 8 LINES
// 1 - leak (porción pasada) ya definido como rightCombPass
combR1FeedbackScaled = h_combStateR1 * rightCombPass;

delayOffsetR1Samples = combDelayR3Smoothed;
combR1DelayOffset = clip(baseOffsetR + delayOffsetR1Samples, 0, samplerate - 1);

combR1Tap = delay_89.read(combR1DelayOffset, interp="linear");

combR1TapScaled = combR1Tap * rightCombLeak;
combR1Mix = combR1TapScaled + combR1FeedbackScaled;

combR1Feedforward = combR1Mix * reflectCoef;
combR1Sum = hpfOutR + combR1Feedforward;
combR1Out = combR1Sum;

next_combStateR1 = fixdenorm(combR1Mix);
// --- Comb R2 (Right) ---
combR2FeedbackScaled = h_combStateR2 * rightCombPass;

delayOffsetR2Samples = combDelayR4Smoothed;
combR2DelayOffset = clip(baseOffsetR + delayOffsetR2Samples, 0, samplerate - 1);

combR2Tap = delay_91.read(combR2DelayOffset, interp="linear");

combR2TapScaled = combR2Tap * rightCombLeak;
combR2Mix = combR2TapScaled + combR2FeedbackScaled;

combR2Feedforward = combR2Mix * reflectCoef;
combR2Sum = hpfOutR + combR2Feedforward;
combR2Out = combR2Sum;

next_combStateR2 = fixdenorm(combR2Mix);
// --- Comb R3 (Right) ---
combR3FeedbackScaled = h_combStateR3 * rightCombPass;

delayOffsetR3Samples = combDelayR6Smoothed;
combR3DelayOffset = clip(baseOffsetR + delayOffsetR3Samples, 0, samplerate - 1);

combR3Tap = delay_93.read(combR3DelayOffset, interp="linear");

combR3TapScaled = combR3Tap * rightCombLeak;
combR3Mix = combR3TapScaled + combR3FeedbackScaled;

combR3Feedforward = combR3Mix * reflectCoef;
combR3Sum = hpfOutR + combR3Feedforward;
combR3Out = combR3Sum;

next_combStateR3 = fixdenorm(combR3Mix);
// --- Comb R4 (Right) ---
combR4FeedbackScaled = h_combStateR4 * rightCombPass;

delayOffsetR4Samples = combDelayR7Smoothed;
combR4DelayOffset = clip(baseOffsetR + delayOffsetR4Samples, 0, samplerate - 1);

combR4Tap = delay_95.read(combR4DelayOffset, interp="linear");

combR4TapScaled = combR4Tap * rightCombLeak;
combR4Mix = combR4TapScaled + combR4FeedbackScaled;

combR4Feedforward = combR4Mix * reflectCoef;
combR4Sum = hpfOutR + combR4Feedforward;
combR4Out = combR4Sum;

next_combStateR4 = fixdenorm(combR4Mix);
// --- Comb R5 (Right) ---
// --- Comb R5 (Right) ---
combR5FeedbackScaled = h_combStateR5 * rightCombPass;

delayOffsetR5Samples = combDelayR1Smoothed;
combR5DelayOffset = clip(baseOffsetR + delayOffsetR5Samples, 0, samplerate - 1);

combR5Tap = delay_97.read(combR5DelayOffset, interp="linear");

combR5TapScaled = combR5Tap * rightCombLeak;
combR5Mix = combR5TapScaled + combR5FeedbackScaled;

combR5Feedforward = combR5Mix * reflectCoef;
combR5Sum = hpfOutR + combR5Feedforward;
combR5Out = combR5Sum;

next_combStateR5 = fixdenorm(combR5Mix);
// --- Comb R6 (Right) ---
// --- Comb R6 (Right) ---
combR6FeedbackScaled = h_combStateR6 * rightCombPass;

delayOffsetR6Samples = combDelayR2Smoothed;
combR6DelayOffset = clip(baseOffsetR + delayOffsetR6Samples, 0, samplerate - 1);

combR6Tap = delay_99.read(combR6DelayOffset, interp="linear");

combR6TapScaled = combR6Tap * rightCombLeak;
combR6Mix = combR6TapScaled + combR6FeedbackScaled;

combR6Feedforward = combR6Mix * reflectCoef;
combR6Sum = hpfOutR + combR6Feedforward;
combR6Out = combR6Sum;

next_combStateR6 = fixdenorm(combR6Mix);
// --- Comb R7 (Right) ---
// --- Comb R7 (Right) ---
combR7FeedbackScaled = h_combStateR7 * rightCombPass;

delayOffsetR7Samples = combDelayR5Smoothed;
combR7DelayOffset = clip(baseOffsetR + delayOffsetR7Samples, 0, samplerate - 1);

combR7Tap = delay_101.read(combR7DelayOffset, interp="linear");

combR7TapScaled = combR7Tap * rightCombLeak;
combR7Mix = combR7TapScaled + combR7FeedbackScaled;

combR7Feedforward = combR7Mix * reflectCoef;
combR7Sum = hpfOutR + combR7Feedforward;
combR7Out = combR7Sum;

next_combStateR7 = fixdenorm(combR7Mix);
// --- Comb R8 (Right) ---
// --- Comb R8 (Right) ---
combR8FeedbackScaled = h_combStateR8 * rightCombPass;

delayOffsetR8Samples = combDelayR8Smoothed;
combR8DelayOffset = clip(baseOffsetR + delayOffsetR8Samples, 0, samplerate - 1);

combR8Tap = delay_103.read(combR8DelayOffset, interp="linear");

combR8TapScaled = combR8Tap * rightCombLeak;
combR8Mix = combR8TapScaled + combR8FeedbackScaled;

combR8Feedforward = combR8Mix * reflectCoef;
combR8Sum = hpfOutR + combR8Feedforward;
combR8Out = combR8Sum;

next_combStateR8 = fixdenorm(combR8Mix);
// Suma normalizada del banco de combs (Right) → early reflections
combMixRight = ((((((((((((((combR8Out + combR7Out)) + combR6Out)) + combR5Out)) + combR4Out)) + combR3Out)) + combR2Out)) + combR1Out)) * 0.125;
earlyRight = combMixRight;

// -----------------------------------------------------------------------------
// ALLPASS DIFFUSER CHAIN (RIGHT) — 4 STAGES
// Entradas: earlyRight
// Salida: msInRight (entrada a matriz M/S)
// apR*Base definidos arriba (Constantes de diseño)
sampleRateScaleAP_R = samplerate / 44100;
apScaleR = sampleRateScaleAP_R * sizeScaleEff;
apR1DelaySamples = apR1Base * apScaleR;
apR1DelayOffset = apBaseR + apR1DelaySamples;
apR1TapA = delay_105.read(apR1DelayOffset, interp="linear");
apR1TapB = delay_106.read(apR1DelayOffset, interp="linear");
// apR1: taps
apR1Sum = (earlyRight * (apGainR * -1)) + (apR1TapA + apR1TapB * apGainR);
// Allpass etapas (Right)
apR1 = apR1Sum;

// -----------------------------------------------------------------------------
// ALLPASS DIFFUSER CHAIN (RIGHT) — 4 STAGES
// BLOQUE: Difusores allpass R
// - Entradas: earlyRight
// - Salida: msInRight (entrada a matriz M/S)

// sampleRateScaleAP_R y apScaleR reutilizados
apR2DelaySamples = apR2Base * apScaleR;
apR2DelayOffset = clip(apBaseR + apR2DelaySamples, 0, samplerate - 1);
apR2TapA = delay_107.read(apR2DelayOffset, interp="linear");
apR2TapB = delay_108.read(apR2DelayOffset, interp="linear");
apR2Sum = apR1 * (apGainR * -1) + (apR2TapA + apR2TapB * apGainR);
apR2 = apR2Sum;

// sampleRateScaleAP_R y apScaleR reutilizados
apR3DelaySamples = apR3Base * apScaleR;
apR3DelayOffset = clip(apBaseR + apR3DelaySamples, 0, samplerate - 1);
apR3TapA = delay_109.read(apR3DelayOffset, interp="linear");
apR3TapB = delay_110.read(apR3DelayOffset, interp="linear");
apR3Sum = apR2 * (apGainR * -1) + (apR3TapA + apR3TapB * apGainR);
apR3 = apR3Sum;

// sampleRateScaleAP_R y apScaleR reutilizados
apR4DelaySamples = apR4Base * apScaleR;
apR4DelayOffset = clip(apBaseR + apR4DelaySamples, 0, samplerate - 1);
apR4TapA = delay_111.read(apR4DelayOffset, interp="linear");
apR4TapB = delay_112.read(apR4DelayOffset, interp="linear");
apR4Sum = apR3 * (apGainR * -1) + (apR4TapA + apR4TapB * apGainR);
apR4 = apR4Sum;
msInRight = apR4;
msMidRaw = msInLeft + msInRight;               // suma L+R (mid)
msMid = msMidRaw * stereoSpreadMid;            // mid con spread
msSideRaw = msInLeft - msInRight;              // diferencia L-R (side)
msSide = msSideRaw * stereoSpreadSide;         // side con spread
msLeftPreWidth = msMid + msSide;               // L previo a width
msLeft = msLeftPreWidth * widthScale;          // aplicar width a L
msRightPreWidth = msMid - msSide;              // R previo a width
msRight = msRightPreWidth * widthScale;        // aplicar width a R

// Alias entrada a matriz M/S (R) y húmedo antes de EQ/COMP
wetPreLeft = msLeft;
wetPreRight = msRight;

// Allpass diffuser out (Right) antes de M/S — ya reflejado en msInRight
// Late reverb (pre EQ/COMP POST)
lateLeft = wetPreLeft;
lateRight = wetPreRight;

// Sección: EQ POST (3 bandas) con bypass eqEnabled
// BLOQUE: Ecualización post reverb
// - Entradas: wetPreLeft/wetPreRight (msLeft/msRight tras M/S+width)
// - Salidas: postEqLeft/postEqRight (con bypass suave si PRE activo)
eqPostLeftRaw, eqPostRightRaw = eq3bandas(wetPreLeft, wetPreRight, lowFreqHz, peakFreqHz, hiFreqHz, lowGainDb, peakGainDb, hiGainDb, 1);

// Si x_prepost=1 (PRE), anula la EQ POST (bypass EQ post)
postEqLeft = mix(msLeft, eqPostLeftRaw, eqEnabled * (1 - prePostBinary));
postEqRight = mix(msRight, eqPostRightRaw, eqEnabled * (1 - prePostBinary));

// Sección: Compresor estéreo (RMS → ganancia → mezcla)
// BLOQUE: Compresión post reverb
// - Entradas: postEqLeft/postEqRight, threshold/ratio/A/R/makeup
// - Salidas: postCOMP_L/postCOMP_R (bypass suave si PRE activo)
// - Detector RMS por canal (~300 muestras) con slide A/R
// - Threshold (s_thd), Ratio (t_ratio), Attack/Release (u_atk/v_rel)
// - Makeup (w_makeup), on/off (r_onoffCOMP)

makeupGainLin = dbtoa(makeupDb);
releaseSamps = mstosamps(releaseMs);
attackSamps = mstosamps(attackMs);
rightWin = int(300);
rightTap = delay_113.read(rightWin);
rightEnergy = postEqRight * postEqRight;
rightAccumPrev = h_postRightAccum;
rightAccum = rightAccumPrev + rightEnergy;
rightDiff = rightAccum - rightTap;
rightAvg = rightDiff / rightWin;
rightRms = sqrt(rightAvg);
next_postRightAccum = fixdenorm(rightDiff);
rightDb = atodb(rightRms);
rightLvlDb = max(rightDb, -96);
rightOver = rightLvlDb > thresholdDb;
rightOverFlagPrev = h_postRightOverFlag;
rightOverSmoothed = (rightOverFlagPrev * 0.999) + (rightOver * 0.001);
next_postRightOverFlag = fixdenorm(rightOverSmoothed);
rightGainDb = (thresholdDb - rightLvlDb) * (1 - (1 / ratio));
rightGainLin = dbtoa(rightGainDb);
// Objetivo de ganancia: 1 bajo umbral, gainLin sobre umbral (sin mezclar expansor)
rightEnvTarget = mix(1, rightGainLin, rightOver);
rightEnv = slide(rightEnvTarget, releaseSamps, attackSamps);
compRight = (postEqRight * rightEnv) * makeupGainLin;
// comp outputs (Left then Right)
leftWin = int(300);
leftTap = delay_116.read(leftWin);
leftEnergy = postEqLeft * postEqLeft;
leftAccumPrev = h_postLeftAccum;
leftAccum = leftAccumPrev + leftEnergy;
leftDiff = leftAccum - leftTap;
leftAvg = leftDiff / leftWin;
leftRms = sqrt(leftAvg);
next_postLeftAccum = fixdenorm(leftDiff);
leftDb = atodb(leftRms);
leftLvlDb = max(leftDb, -96);
leftOver = leftLvlDb > thresholdDb;
leftOverFlagPrev = h_postLeftOverFlag;
leftOverSmoothed = (leftOverFlagPrev * 0.999) + (leftOver * 0.001);
next_postLeftOverFlag = fixdenorm(leftOverSmoothed);
leftGainDb = (thresholdDb - leftLvlDb) * (1 - (1 / ratio));
leftGainLin = dbtoa(leftGainDb);
leftEnvTarget = mix(1, leftGainLin, leftOver);
leftEnv = slide(leftEnvTarget, releaseSamps, attackSamps);
compLeft = (postEqLeft * leftEnv) * makeupGainLin;

// Si x_prepost=1 (PRE), anula el COMP POST
postCOMP_L = mix(postEqLeft, compLeft, compEnableSmoothed * (1 - prePostBinary));
postCOMP_R = mix(postEqRight, compRight, compEnableSmoothed * (1 - prePostBinary));
postCompLeft = postCOMP_L;
postCompRight = postCOMP_R;
wetPostCompLeft = postCOMP_L;
wetPostCompRight = postCOMP_R;

// -----------------------------------------------------------------------------
// SALIDA (DRY/WET + MONO COLLAPSE)
// BLOQUE: Mezcla y salida final
// - Entradas: dryL/dryR, wetPostCompLeft/wetPostCompRight, dryWet, outputTrimLin, isMonoOut
// - Operaciones: trim + softclip (solo WET), mix dry/wet por canal, DC-block, mezcla mono si procede
// - Salidas: out1/out2 (requeridos por Max/Gen)
wetOutL = wetPostCompLeft * outputTrimLin;
wetOutR = wetPostCompRight * outputTrimLin;

// --- WOBBLE ESTÉREO (aleatorio suavizado) justo ANTES del DUCK ---
// Reloj de S&H para objetivo aleatorio
phaseInc = ag_WOBBLE_RATE / samplerate;
phaseNext = h_wobblePhase + phaseInc;
wrapWob = phaseNext >= 1;
currentPhase = wrapWob ? (phaseNext - 1) : phaseNext;

// LCG simple para generar ruido determinista [-1,1]
seedNext = fract(h_wobbleSeed * 1103515245.0 + 12345.0);
noiseRand = (seedNext * 2) - 1;

// Sample & hold de objetivo
wobbleTargetNext = wrapWob ? noiseRand : h_wobbleTarget;

// Slew adaptativo según RATE (~20% del periodo), limitado entre 30 y 300 ms
periodMs = 1000 / max(ag_WOBBLE_RATE, 0.05);
slewMs   = clip(periodMs * 0.2, 0.01, 300);
wobbleSlewed = slide(wobbleTargetNext, mstosamps(slewMs), mstosamps(slewMs));

// Profundidad en dB máx ≈ 6 dB, escalada por af_WOBBLE_AMT
wobbleDepthDb = af_WOBBLE_AMT * 6;
wobbleDepthLin = dbtoa(wobbleDepthDb);

// Respetar el spread actual: escalar por stereoWidthParam
panEff = wobbleSlewed * stereoWidthParam;

// Ganancias antisimétricas y normalización suave de energía
gL_wob = pow(wobbleDepthLin,  panEff);
gR_wob = pow(wobbleDepthLin, -panEff);
wobNorm = 1 / sqrt(((gL_wob * gL_wob) + (gR_wob * gR_wob)) * 0.5);

wetWobL = wetOutL * gL_wob * wobNorm;
wetWobR = wetOutR * gR_wob * wobNorm;

// Aplicar solo si está activado
wetPreDuckL = mix(wetOutL, wetWobL, ae_WOBBLE_ON);
wetPreDuckR = mix(wetOutR, wetWobR, ae_WOBBLE_ON);

// Ducking in dB based on dry RMS
// Detector: dry input (ioL_raw/ioR_raw)
dryEnergy = (ioL_raw * ioL_raw + ioR_raw * ioR_raw) * 0.5;
dryEnv = slide(dryEnergy, mstosamps(ac_DUCK_ATK), mstosamps(ad_DUCK_REL)); // up=ATK, down=REL
// Detector más agresivo (*4) para que dispare antes
dryNorm = min(sqrt(dryEnv) * 4, 1);

// Duck envelope en dB: ab_DUCK_DB ya es negativo (0..-60)
duckReductionDb = ab_DUCK_DB * dryNorm;
duckGain = dbtoa(duckReductionDb);
duckEnv = mix(1, duckGain, aa_DUCK_ON);

wetDuckedL = wetPreDuckL * duckEnv;
wetDuckedR = wetPreDuckR * duckEnv;

// Softclip solo en la rama WET
// wetClipL = 0.6366342928 * tanh(wetOutL);
// wetClipR = 0.6366342928 * tanh(wetOutR);
// wetProcessedL = mix(wetOutL, wetClipL, 0); //softclipEnabled
// wetProcessedR = mix(wetOutR, wetClipR, 0); //softclipEnabled

// Mezcla Dry/Wet y bypass interno (suavizado)
mixedLeft  = mix(dryL, wetDuckedL, dryWet);
mixedRight = mix(dryR, wetDuckedR, dryWet);

finalLeftPre  = mix(mixedLeft, dryL, bypassSmoothed);
finalRightPre = mix(mixedRight, dryR, bypassSmoothed);

dcblockLeft  = dcblock(finalLeftPre);
dcblockRight = dcblock(finalRightPre);

// outMono/out mix computed after both channels are available
outMono = (dcblockLeft + dcblockRight) * 0.5;
out1 = mix(dcblockLeft, outMono, isMonoOut);
out2 = mix(dcblockRight, outMono, isMonoOut);

// Salidas auxiliares para host (POST TRIM IN): out5 (L), out6 (R)
// Nota: expone la entrada tras el trim de entrada (a_INPUT), antes de procesar reverb
// Si prefieres tras el routing mono (ioL/ioR), cambia leftTrimmed/rightTrimmed por ioL/ioR
out4 = leftTrimmed;
out5 = rightTrimmed;

// -----------------------------------------------------------------------------
// STATE UPDATES (History/Delay writes) — must follow outputs
// -----------------------------------------------------------------------------
// --- Estados PRE (si se usa x_prepost=1) ---
// --- PRE COMP state updates ---
delay_preR.write(preRightEnergy);
preR_accum = preR_accum_next;
preR_flag = fixdenorm(preR_flag_s);
delay_preL.write(preLeftEnergy);
preL_accum = preL_accum_next;
preL_flag = fixdenorm(preL_flag_s);
// Reverb drive RMS state updates
// (Eliminadas escrituras de detectores RAW)
h_outputTrim = next_outputTrim;
// Post COMP detector state updates
h_postLeftOverFlag = next_postLeftOverFlag;
h_postLeftAccum = next_postLeftAccum;
delay_116.write(leftEnergy);
// Right channel RMS + over flag updates
h_postRightOverFlag = next_postRightOverFlag;
h_postRightAccum = next_postRightAccum;
delay_113.write(rightEnergy);
// --- ALLPASS R state updates ---
delay_106.write(apR1Sum);
delay_107.write(apR1);
delay_108.write(apR2Sum);
delay_109.write(apR2);
delay_110.write(apR3Sum);
delay_111.write(apR3);
delay_112.write(apR4Sum);
delay_105.write(earlyRight);
// Right comb delay smoothing state updates
h_combDelayR8 = next_combDelayR8;
h_combDelayR7 = next_combDelayR7;
h_combDelayR6 = next_combDelayR6;
h_combDelayR5 = next_combDelayR5;
h_combDelayR4 = next_combDelayR4;
h_combDelayR3 = next_combDelayR3;
h_combDelayR2 = next_combDelayR2;
// --- COMB R state updates ---
delay_89.write(combR1Sum);
// Right comb integrator state updates
h_combStateR1 = next_combStateR1;
delay_91.write(combR2Sum);
h_combStateR2 = next_combStateR2;
delay_93.write(combR3Sum);
h_combStateR3 = next_combStateR3;
delay_95.write(combR4Sum);
h_combStateR4 = next_combStateR4;
delay_97.write(combR5Sum);
h_combStateR5 = next_combStateR5;
delay_99.write(combR6Sum);
h_combStateR6 = next_combStateR6;
delay_101.write(combR7Sum);
h_combStateR7 = next_combStateR7;
delay_103.write(combR8Sum);
h_combStateR8 = next_combStateR8;
h_combDelayR1 = next_combDelayR1;
// --- ALLPASS L state updates ---
delay_74.write(apL1Sum);
delay_75.write(apL1);
delay_76.write(apL2Sum);
delay_77.write(apL2);
delay_78.write(apL3Sum);
delay_79.write(apL3);
delay_80.write(apL4Sum);
delay_73.write(earlyLeft);
// Left comb delay smoothing state updates
h_combDelayL8 = next_combDelayL8;
h_combDelayL7 = next_combDelayL7;
h_combDelayL6 = next_combDelayL6;
h_combDelayL5 = next_combDelayL5;
h_combDelayL4 = next_combDelayL4;
h_combDelayL3 = next_combDelayL3;
h_combDelayL2 = next_combDelayL2;
// --- COMB L delay/history updates ---
delay_57.write(combL1Sum);
// Left comb integrator state updates
h_combStateL1 = next_combStateL1;
delay_59.write(combL2Sum);
h_combStateL2 = next_combStateL2;
delay_61.write(combL3Sum);
h_combStateL3 = next_combStateL3;
delay_63.write(combL4Sum);
h_combStateL4 = next_combStateL4;
delay_65.write(combL5Sum);
h_combStateL5 = next_combStateL5;
delay_67.write(combL6Sum);
h_combStateL6 = next_combStateL6;
delay_69.write(combL7Sum);
h_combStateL7 = next_combStateL7;
delay_71.write(combL8Sum);
h_combStateL8 = next_combStateL8;
h_combDelayL1 = next_combDelayL1;
history_40 = nextLpfOutL;
history_39 = nextLpfOutR;
history_38 = nextPreInputR;
history_37 = nextPreInputL;
history_36 = history_36_next_355;
history_35 = history_35_next_354;
history_34 = history_34_next_353;
history_41 = history_41_next_374;
history_48 = history_48_next_381;
history_47 = history_47_next_380;
history_46 = history_46_next_379;
history_45 = history_45_next_378;
history_44 = history_44_next_377;
history_43 = history_43_next_376;
history_42 = history_42_next_375;
history_33 = history_33_next_352;
h_freezeGate = nextFreezeGate;
h_reflectCoef = nextReflectCoef;
h_hpfHz = nextHpfHz;
h_lpfHz = nextLpfHz;
h_sizeScale = nextSizeScale;
// Smoothed parameter state updates
h_inputTrim = next_inputTrim;
h_hiGainDb = next_hiGainDb;
h_peakGainDb = next_peakGainDb;
h_lowGainDb = next_lowGainDb;
h_hiFreqHz = next_hiFreqHz;
h_peakFreqHz = next_peakFreqHz;
h_lowFreqHz = next_lowFreqHz;
h_stereoWidth = next_stereoWidth;
h_freezeBlend = next_freezeBlend;
h_eqEnabled = next_eqEnabled;
h_dryWetStage2 = next_dryWetStage2;
h_dryWetStage1 = next_dryWetStage1;
h_makeupDb = next_makeupDb;
h_releaseMs = next_releaseMs;
h_attackMs = next_attackMs;
h_ratio = next_ratio;
h_thresholdDb = next_thresholdDb;
h_compEnable = next_compEnable;
h_outputTrim = next_outputTrim;

// Softclip enable state update
//h_softclipEnable = next_softclipEnable;

// Internal bypass state update
h_bypass = next_bypass;
// Pre/Post gap env state
h_prepostGap = next_prepostGap;
// PRE/POST switch envelope update (legacy blend state)
prePost_s = fixdenorm(prePostBlend);

h_wobblePhase = currentPhase;
h_wobbleTarget = wobbleTargetNext;
h_wobbleSeed = seedNext;
